---
globs: *.dart
description: Dart/Flutter coding style, naming conventions, and best practices
---

# Dart/Flutter Coding Style & Conventions

## Code Style Guidelines
- **Lints**: Use `flutter_lints` (configured in `analysis_options.yaml`)
- **Indentation**: 2 spaces (not tabs)
- **Logging**: Avoid `print()` statements; use `AppLogger` utility instead
- **Code Generation**: Run `dart run build_runner build --delete-conflicting-outputs` after modifying annotated classes
- **Environment Configuration**: Use `AppConfig` for environment-specific settings loaded from `.env` files

## Naming Conventions
- **Files**: `lower_snake_case.dart`
- **Classes/Types**: `PascalCase` (e.g., `AuthController`, `UserModel`)
- **Variables/Methods**: `camelCase` (e.g., `currentUser`, `login()`)
- **Constants**: `SCREAMING_SNAKE_CASE` (e.g., `API_BASE_URL`)
- **Private Members**: Prefix with underscore `_privateMember` (e.g., `_authRepository`)
- **Rx Observables**: Use descriptive names with `.obs` (e.g., `isLoading.obs`, `currentUser.obs`)

## Code Organization
- **Business Logic**: Keep in `controllers/` and `repositories/`
- **UI Logic**: Keep in `views/` and `widgets/`
- **Data Models**: Simple POJOs in `models/` with JSON serialization (use `@JsonSerializable`)
- **API Calls**: Use `Dio` with custom providers in `providers/`
- **External Services**: Abstract in `services/` layer (Supabase, Storage, Location, etc.)
- **Configuration**: Environment-specific config in `config/environments/`

## Best Practices
- Use dependency injection through GetX bindings with `lazyPut` for controllers
- Follow single responsibility principle for controllers (auth, listing, booking, etc.)
- Keep widgets stateless when possible, use GetX for state management with `Obx`
- Use repositories to abstract data sources and handle API responses
- Implement proper error handling with custom exceptions (`ApiException`, etc.)
- Use `AppLogger` for all logging with appropriate levels (debug, info, warning, error)
- Use reactive programming patterns with Rx types for UI state management
- Implement form validation with reactive error observables
- Use extension methods for common utility functions

## Common Patterns
```dart
// Controller pattern with AppLogger and error handling
class AuthController extends GetxController {
  final AuthRepository _authRepository;

  AuthController({required AuthRepository authRepository})
      : _authRepository = authRepository;

  // Reactive state variables
  final Rx<UserModel?> currentUser = Rx<UserModel?>(null);
  final RxBool isLoading = false.obs;
  final RxBool isAuthenticated = false.obs;

  // Form validation observables
  final RxString emailError = ''.obs;
  final RxString passwordError = ''.obs;

  @override
  void onInit() {
    super.onInit();
    _checkAuthStatus();
  }

  Future<void> login({required String email, required String password}) async {
    try {
      isLoading.value = true;

      // Clear previous errors
      emailError.value = '';
      passwordError.value = '';

      // Validation
      if (email.isEmpty) {
        emailError.value = 'Email is required';
        return;
      }

      final user = await _authRepository.loginWithEmail(
        email: email,
        password: password,
      );

      currentUser.value = user;
      isAuthenticated.value = true;

      AppLogger.info('Login successful for user: ${user.email}');
      Get.offAllNamed(Routes.home);

    } on ApiException catch (e) {
      AppLogger.error('Login failed: ${e.message}', e);
      _handleApiError('Login Failed', e);
    } catch (e) {
      AppLogger.error('Login error', e);
      Get.snackbar('Error', 'An unexpected error occurred');
    } finally {
      isLoading.value = false;
    }
  }
}

// Repository pattern with Dio
class AuthRepository {
  final AuthProvider _authProvider;

  AuthRepository(this._authProvider);

  Future<UserModel> loginWithEmail({
    required String email,
    required String password,
  }) async {
    final response = await _authProvider.login(
      email: email,
      password: password,
    );
    return UserModel.fromJson(response.data);
  }
}

// Provider pattern with Dio
class AuthProvider {
  final Dio _dio;

  AuthProvider(this._dio) {
    _dio.options.baseUrl = AppConfig.I.apiBaseUrl;
  }

  Future<Response> login({
    required String email,
    required String password,
  }) async {
    try {
      final response = await _dio.post(
        '/auth/login',
        data: {'email': email, 'password': password},
      );
      return response;
    } on DioException catch (e) {
      throw ApiException.fromDioError(e);
    }
  }
}
```