---
globs: *_test.dart
description: Testing frameworks, structure, and best practices for Flutter app
---

# Testing Guidelines & Structure

## Testing Frameworks
- **Unit Tests**: `flutter_test` framework
- **Mocking**: `mockito` for mocking dependencies
- **Integration Tests**: `integration_test` package
- **Widget Tests**: `flutter_test` with widget testing utilities

## Test File Organization (Actual Structure)
Current test structure in the codebase:

```
test/
├── unit/                    # Unit tests
│   └── controllers/         # Controller tests (only existing)
│       └── auth_controller_test.dart
├── widget/                  # Widget tests
│   └── widget_test.dart     # Basic widget test template
└── integration/            # Integration tests (empty, but structure exists)

# Missing but should be added:
├── unit/
│   ├── repositories/        # Repository tests
│   ├── services/            # Service tests
│   └── utils/              # Utility tests
├── widget/
│   ├── views/              # View component tests
│   └── widgets/            # Widget tests
└── integration/
    ├── auth_flow_test.dart
    ├── booking_flow_test.dart
    └── payment_flow_test.dart
```

## Test File Naming (Actual Pattern)
- All test files must end with `_test.dart`
- Mirror the source file structure and naming
- Example: `auth_controller.dart` → `auth_controller_test.dart`
- Current: `test/unit/controllers/auth_controller_test.dart`

## Testing Scope & Coverage
- **Controllers**: Test business logic, state management, error handling
- **Providers**: Test API calls, response handling, error scenarios
- **Middleware/Route Guards**: Test authentication, authorization logic
- **Critical Navigation**: Test navigation flows and guards
- **Integration**: Test complete user flows (login → booking → payment)

## Unit Testing Patterns
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

// Generate mocks
@GenerateMocks([AuthRepository])
import 'auth_controller_test.mocks.dart';

void main() {
  late AuthController authController;
  late MockAuthRepository mockAuthRepository;

  setUp(() {
    mockAuthRepository = MockAuthRepository();
    authController = AuthController(mockAuthRepository);
  });

  group('AuthController', () {
    test('should login successfully', () async {
      // Arrange
      const email = 'test@example.com';
      const password = 'password123';
      final user = User(id: '1', email: email);

      when(mockAuthRepository.login(email, password))
          .thenAnswer((_) async => user);

      // Act
      await authController.login(email, password);

      // Assert
      expect(authController.currentUser.value, user);
      verify(mockAuthRepository.login(email, password)).called(1);
    });

    test('should handle login error', () async {
      // Arrange
      when(mockAuthRepository.login(any, any))
          .thenThrow(Exception('Login failed'));

      // Act & Assert
      expect(
        () => authController.login('test@example.com', 'wrong'),
        throwsA(isA<Exception>()),
      );
    });
  });
}
```

## Widget Testing Patterns (Actual Example)
Current widget test pattern from `test/widget_test.dart`:

```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter_test/flutter_test.dart';
import 'package:get/get.dart';
import 'package:flutter/material.dart';

import 'package:stays_app/app/ui/theme/app_theme.dart';

void main() {
  testWidgets('App builds root GetMaterialApp', (WidgetTester tester) async {
    final app = GetMaterialApp(
      theme: AppTheme.lightTheme,
      home: const Scaffold(body: Center(child: Text('Hello'))),
    );
    await tester.pumpWidget(app);
    expect(find.text('Hello'), findsOneWidget);
  });
}
```

### Recommended Widget Testing Pattern
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

void main() {
  setUp(() {
    Get.testMode = true;
  });

  testWidgets('LoginView displays validation errors', (tester) async {
    // Arrange - Build the widget with GetMaterialApp
    await tester.pumpWidget(
      GetMaterialApp(
        home: const LoginView(),
      ),
    );

    // Find form fields using keys or text
    final emailField = find.byKey(const Key('email_field'));
    final passwordField = find.byKey(const Key('password_field'));
    final loginButton = find.byKey(const Key('login_button'));

    // Act - Test empty form submission
    await tester.tap(loginButton);
    await tester.pump();

    // Assert - Verify validation errors are shown
    expect(find.text('Email or phone is required'), findsOneWidget);
    expect(find.text('Password is required'), findsOneWidget);
  });

  testWidgets('LoginView shows loading state', (tester) async {
    // Test loading state during API call
    await tester.pumpWidget(
      GetMaterialApp(
        home: const LoginView(),
      ),
    );

    // Fill form and submit
    await tester.enterText(find.byKey(const Key('email_field')), 'test@example.com');
    await tester.enterText(find.byKey(const Key('password_field')), 'password123');
    await tester.tap(find.byKey(const Key('login_button')));
    await tester.pump(); // Show loading state

    // Verify loading indicator appears
    expect(find.byType(CircularProgressIndicator), findsOneWidget);
  });
}
```

## Integration Testing Patterns (Recommended)
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:stays_app/main_dev.dart' as app;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('end-to-end test', () {
    testWidgets('complete authentication flow', (tester) async {
      // Launch the app in development mode
      app.main();
      await tester.pumpAndSettle();

      // Wait for splash screen
      await tester.pump(const Duration(seconds: 2));

      // Navigate to login if not already there
      final loginButton = find.byKey(const Key('login_button'));
      if (loginButton.evaluate().isNotEmpty) {
        await tester.tap(loginButton);
        await tester.pumpAndSettle();
      }

      // Fill login form with email
      await tester.enterText(
        find.byKey(const Key('email_field')),
        'test@example.com',
      );
      await tester.enterText(
        find.byKey(const Key('password_field')),
        'password123',
      );

      // Submit login
      await tester.tap(find.byKey(const Key('login_button')));
      await tester.pumpAndSettle();

      // Verify successful login and navigation to home
      expect(find.byKey(const Key('home_screen')), findsOneWidget);

      // Test navigation to profile
      await tester.tap(find.byKey(const Key('profile_tab')));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('profile_screen')), findsOneWidget);
    });

    testWidgets('booking flow integration', (tester) async {
      // Launch app and login first (could reuse login logic)
      app.main();
      await tester.pumpAndSettle();

      // Navigate to explore/listing
      await tester.tap(find.byKey(const Key('explore_tab')));
      await tester.pumpAndSettle();

      // Select a property
      await tester.tap(find.byKey(const Key('property_card_1')));
      await tester.pumpAndSettle();

      // Test booking flow
      await tester.tap(find.byKey(const Key('book_now_button')));
      await tester.pumpAndSettle();

      // Verify booking screen loads
      expect(find.byKey(const Key('booking_screen')), findsOneWidget);
    });
  });
}
```

## Test Coverage Requirements
- Aim for >80% code coverage
- Cover happy path and error scenarios
- Test edge cases and boundary conditions
- Mock external dependencies (API calls, database, etc.)
- Use descriptive test names that explain the scenario