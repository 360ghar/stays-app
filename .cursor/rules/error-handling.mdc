---
globs: *.dart
description: Error handling patterns and exception management for Flutter app
---

# Error Handling & Exception Management

## Actual Exception Hierarchy (Used in Codebase)
Current exception classes from the implementation:

```dart
// lib/app/utils/exceptions/app_exceptions.dart
class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic originalError;

  AppException({required this.message, this.code, this.originalError});

  @override
  String toString() => message;
}

class NetworkException extends AppException {
  final int? statusCode;
  NetworkException({
    required super.message,
    this.statusCode,
    super.code,
    super.originalError,
  });
}

class ApiException extends NetworkException {
  ApiException({required super.message, super.statusCode, super.code});
}

class AuthException extends AppException {
  AuthException({required super.message, super.code});
}

class ValidationException extends AppException {
  final Map<String, List<String>> errors;
  ValidationException({
    required this.errors,
    super.message = 'Validation failed',
  });
}

// lib/app/utils/exceptions/auth_exceptions.dart
class TokenExpiredException extends AuthException {
  TokenExpiredException()
    : super(message: 'Token expired', code: 'token_expired');
}

// lib/app/utils/exceptions/network_exceptions.dart
class NetworkExceptions extends NetworkException {
  NetworkExceptions({
    required super.message,
    super.statusCode,
    super.code,
    super.originalError,
  });
}
```

## Error Handling in Controllers (Actual Implementation)
Current error handling patterns used in AuthController:

```dart
class AuthController extends GetxController {
  final AuthRepository _authRepository;

  AuthController({required AuthRepository authRepository})
      : _authRepository = authRepository;

  final RxBool isLoading = false.obs;
  final RxString emailOrPhoneError = ''.obs;
  final RxString passwordError = ''.obs;

  Future<void> login({required String email, required String password}) async {
    try {
      isLoading.value = true;

      // Clear previous errors
      emailOrPhoneError.value = '';
      passwordError.value = '';

      // Validation logic here...

      UserModel user;
      if (GetUtils.isEmail(email)) {
        user = await _authRepository.loginWithEmail(
          email: email,
          password: password,
        );
      } else {
        user = await _authRepository.loginWithPhone(
          phone: email,
          password: password,
        );
      }

      currentUser.value = user;
      isAuthenticated.value = true;

      AppLogger.info('Login successful for user: ${user.email ?? user.phone}');
      Get.offAllNamed(Routes.home);

    } on ApiException catch (e) {
      AppLogger.error('Login failed: ${e.message}', e);
      _handleApiError('Login Failed', e);
    } catch (e) {
      AppLogger.error('Login error', e);
      Get.snackbar('Error', 'An unexpected error occurred');
    } finally {
      isLoading.value = false;
    }
  }

  void _handleApiError(String title, ApiException e) {
    String message;
    switch (e.statusCode) {
      case 401:
        message = 'Invalid credentials. Please check your email/phone and password.';
        break;
      case 404:
        message = 'Account not found. Please check your credentials or sign up.';
        break;
      case 422:
        message = 'Invalid input. Please check your information and try again.';
        break;
      case 429:
        message = 'Too many attempts. Please try again later.';
        break;
      case 500:
        message = 'Server error. Please try again later.';
        break;
      default:
        message = e.message.isNotEmpty
            ? e.message
            : 'An error occurred. Please try again.';
    }
    _showErrorSnackbar(title: title, message: message);
  }

  void _showErrorSnackbar({required String title, required String message}) {
    Get.snackbar(
      '',
      '',
      titleText: Text(
        title,
        style: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 18,
        ),
      ),
      messageText: Text(
        message,
        style: const TextStyle(color: Colors.white70, fontSize: 14),
      ),
      backgroundColor: const Color(0xFFE91E63).withValues(alpha: 0.9),
      borderRadius: 16,
      margin: const EdgeInsets.all(16),
      duration: const Duration(seconds: 4),
      animationDuration: const Duration(milliseconds: 500),
      snackPosition: SnackPosition.TOP,
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: const BoxDecoration(
          color: Colors.white24,
          shape: BoxShape.circle,
        ),
        child: const Icon(Icons.error_outline, color: Colors.white, size: 24),
      ),
    );
  }
}
```

## Error Handling in Providers (Actual Dio Implementation)
Current provider error handling patterns using Dio:

```dart
class AuthProvider {
  final Dio _dio;

  AuthProvider(this._dio) {
    _dio.options.baseUrl = AppConfig.I.apiBaseUrl;
    _dio.options.connectTimeout = const Duration(seconds: 30);
    _dio.options.receiveTimeout = const Duration(seconds: 30);

    // Add interceptors
    _dio.interceptors.add(
      PrettyDioLogger(
        requestHeader: true,
        requestBody: true,
        responseHeader: true,
        responseBody: true,
        error: true,
        compact: true,
      ),
    );
  }

  Future<Response> login({required String email, required String password}) async {
    try {
      final response = await _dio.post(
        '/auth/login',
        data: {'email': email, 'password': password},
      );
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    } catch (e) {
      AppLogger.error('Login API error', e);
      throw ApiException(message: 'Login failed. Please try again.');
    }
  }

  ApiException _handleDioError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return ApiException(
          message: 'Request timeout. Please check your connection.',
          statusCode: e.response?.statusCode,
        );

      case DioExceptionType.badResponse:
        final statusCode = e.response?.statusCode;
        final responseData = e.response?.data;

        String message = 'An error occurred';
        if (responseData is Map<String, dynamic>) {
          message = responseData['message'] ?? responseData['error'] ?? message;
        }

        return ApiException(
          message: message,
          statusCode: statusCode,
        );

      case DioExceptionType.cancel:
        return ApiException(message: 'Request was cancelled');

      case DioExceptionType.unknown:
        if (e.error is SocketException) {
          return ApiException(message: 'No internet connection. Please check your network.');
        }
        return ApiException(message: 'Network error. Please try again.');

      default:
        return ApiException(message: 'An unexpected error occurred');
    }
  }
}
```

## Error Handling in UI (Actual Patterns)
Current UI error handling patterns used in the app:

```dart
class LoginView extends GetView<AuthController> {
  const LoginView({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // Email/Phone error display
            Obx(() {
              if (controller.emailOrPhoneError.value.isNotEmpty) {
                return Container(
                  padding: const EdgeInsets.all(12),
                  margin: const EdgeInsets.only(bottom: 16),
                  decoration: BoxDecoration(
                    color: Colors.red.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.red.shade200),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.error, color: Colors.red.shade400),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          controller.emailOrPhoneError.value,
                          style: TextStyle(color: Colors.red.shade700),
                        ),
                      ),
                    ],
                  ),
                );
              }
              return const SizedBox.shrink();
            }),

            // Password error display
            Obx(() {
              if (controller.passwordError.value.isNotEmpty) {
                return Container(
                  padding: const EdgeInsets.all(12),
                  margin: const EdgeInsets.only(bottom: 16),
                  decoration: BoxDecoration(
                    color: Colors.red.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.red.shade200),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.error, color: Colors.red.shade400),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          controller.passwordError.value,
                          style: TextStyle(color: Colors.red.shade700),
                        ),
                      ),
                    ],
                  ),
                );
              }
              return const SizedBox.shrink();
            }),

            // Loading indicator overlay
            Obx(() {
              if (controller.isLoading.value) {
                return Container(
                  color: Colors.black.withValues(alpha: 0.3),
                  child: const Center(
                    child: CircularProgressIndicator(),
                  ),
                );
              }
              return const SizedBox.shrink();
            }),

            // Login form with reactive fields...
          ],
        ),
      ),
    );
  }
}
```

### Alternative: Using GetX Snackbars for Global Errors
```dart
// In controller methods
_showSuccessSnackbar({required String title, required String message}) {
  Get.snackbar(
    '',
    '',
    titleText: Text(
      title,
      style: const TextStyle(
        color: Colors.white,
        fontWeight: FontWeight.bold,
        fontSize: 18,
      ),
    ),
    messageText: Text(
      message,
      style: const TextStyle(color: Colors.white70, fontSize: 14),
    ),
    backgroundColor: const Color(0xFF4CAF50).withValues(alpha: 0.9),
    borderRadius: 16,
    margin: const EdgeInsets.all(16),
    duration: const Duration(seconds: 3),
    snackPosition: SnackPosition.TOP,
    icon: Container(
      padding: const EdgeInsets.all(8),
      decoration: const BoxDecoration(
        color: Colors.white24,
        shape: BoxShape.circle,
      ),
      child: const Icon(Icons.check_circle, color: Colors.white, size: 24),
    ),
  );
}
```

## Global Error Handling (Actual Implementation)
Current global error handling setup:

```dart
// lib/main_dev.dart (similar for main_staging.dart and main_prod.dart)
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dotenv.load(fileName: '.env.dev');
  AppConfig.setConfig(AppConfig.dev());

  // Global error handling
  FlutterError.onError = (FlutterErrorDetails details) {
    AppLogger.error('Flutter Error: ${details.exception}', details.exception, details.stack);
    // In development, also print to console
    if (AppConfig.I.environment == 'dev') {
      FlutterError.dumpErrorToConsole(details);
    }
  };

  // Handle platform errors
  PlatformDispatcher.instance.onError = (error, stack) {
    AppLogger.error('Platform Error', error, stack);
    return true; // Prevent the app from crashing
  };

  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  runApp(const MyApp());
}
```

### Error Recovery Strategies
Implement error recovery patterns:

```dart
class ErrorRecoveryService {
  static Future<bool> attemptRecovery(AppException exception) async {
    switch (exception.runtimeType) {
      case TokenExpiredException:
        return await _handleTokenExpired(exception as TokenExpiredException);
      case ApiException:
        return await _handleApiException(exception as ApiException);
      default:
        return false;
    }
  }

  static Future<bool> _handleTokenExpired(TokenExpiredException exception) async {
    try {
      // Attempt to refresh token
      final authController = Get.find<AuthController>();
      await authController.refreshToken();
      return true;
    } catch (_) {
      // Force logout on refresh failure
      final authController = Get.find<AuthController>();
      await authController.logout();
      return false;
    }
  }

  static Future<bool> _handleApiException(ApiException exception) async {
    if (exception.statusCode == 429) {
      // Rate limited - wait and retry
      await Future.delayed(const Duration(seconds: 5));
      return true;
    }
    if (exception.statusCode == 503) {
      // Service unavailable - show maintenance message
      Get.snackbar(
        'Service Unavailable',
        'The service is temporarily unavailable. Please try again later.',
        snackPosition: SnackPosition.TOP,
      );
      return false;
    }
    return false;
  }
}
```

## Validation Error Handling (Actual Implementation)
Current validation patterns used in controllers:

```dart
// In AuthController - inline validation methods
class AuthController extends GetxController {
  // Validation observables
  final RxString emailOrPhoneError = ''.obs;
  final RxString passwordError = ''.obs;
  final RxString confirmPasswordError = ''.obs;

  // Validation helper methods
  String? _validateEmailOrPhone(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Email or phone is required';
    }
    return null;
  }

  String? _validatePassword(String? password) {
    if (password == null || password.isEmpty) {
      return 'Password is required';
    }
    if (password.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }

  String? _validateConfirmPassword(String? password, String? confirmPassword) {
    if (confirmPassword == null || confirmPassword.isEmpty) {
      return 'Please confirm your password';
    }
    if (password != confirmPassword) {
      return 'Passwords do not match';
    }
    return null;
  }

  // Usage in login method
  Future<void> login({required String email, required String password}) async {
    // Clear previous errors
    emailOrPhoneError.value = '';
    passwordError.value = '';

    // Validate
    final emailValidation = _validateEmailOrPhone(email);
    final passwordValidation = _validatePassword(password);

    if (emailValidation != null) {
      emailOrPhoneError.value = emailValidation;
      return;
    }
    if (passwordValidation != null) {
      passwordError.value = passwordValidation;
      return;
    }

    // Proceed with API call...
  }
}
```

### Alternative: Centralized Validation Service
```dart
class ValidationService {
  static Map<String, String> validateLogin(String email, String password) {
    final errors = <String, String>{};

    if (email.trim().isEmpty) {
      errors['email'] = 'Email is required';
    } else if (!GetUtils.isEmail(email)) {
      errors['email'] = 'Please enter a valid email address';
    }

    if (password.isEmpty) {
      errors['password'] = 'Password is required';
    } else if (password.length < 6) {
      errors['password'] = 'Password must be at least 6 characters';
    }

    return errors;
  }

  static Map<String, String> validateRegistration({
    required String name,
    required String email,
    required String password,
    required String confirmPassword,
  }) {
    final errors = <String, String>{};

    if (name.trim().isEmpty) {
      errors['name'] = 'Name is required';
    }

    if (email.trim().isEmpty) {
      errors['email'] = 'Email is required';
    } else if (!GetUtils.isEmail(email)) {
      errors['email'] = 'Please enter a valid email address';
    }

    if (password.isEmpty) {
      errors['password'] = 'Password is required';
    } else if (password.length < 6) {
      errors['password'] = 'Password must be at least 6 characters';
    }

    if (confirmPassword.isEmpty) {
      errors['confirmPassword'] = 'Please confirm your password';
    } else if (password != confirmPassword) {
      errors['confirmPassword'] = 'Passwords do not match';
    }

    return errors;
  }
}
```

## Logging Strategy (Actual Implementation)
Current logging patterns used throughout the app:

```dart
// lib/app/utils/logger/app_logger.dart
class AppLogger {
  static final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 1,
      errorMethodCount: 5,
      lineLength: 80,
      colors: true,
      printEmojis: true,
      dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart,
    ),
    level: _getLogLevel(),
  );

  static Level _getLogLevel() {
    if (AppConfig.isProduction) return Level.warning;
    if (AppConfig.isStaging) return Level.info;
    return Level.trace; // Development
  }

  static void debug(String message, [dynamic data]) =>
      _logger.d(_fmt(message, data));
  static void info(String message, [dynamic data]) =>
      _logger.i(_fmt(message, data));
  static void warning(String message, [dynamic data]) =>
      _logger.w(_fmt(message, data));
  static void error(String message, [dynamic error, StackTrace? stackTrace]) =>
      _logger.e(_fmt(message, error), stackTrace: stackTrace);

  static void logRequest(dynamic request) =>
      _logger.d(_fmt('API Request', request));
  static void logResponse(dynamic response) =>
      _logger.d(_fmt('API Response', response));

  static String _fmt(String message, [dynamic data]) =>
      data == null ? message : '$message | ${data.toString()}';
}

// Usage throughout the app
class AuthController extends GetxController {
  Future<void> login({required String email, required String password}) async {
    try {
      AppLogger.info('Attempting login for: $email');

      // API call...
      final user = await _authRepository.loginWithEmail(
        email: email,
        password: password,
      );

      AppLogger.info('Login successful for user: ${user.email}');
      Get.offAllNamed(Routes.home);

    } on ApiException catch (e) {
      AppLogger.error('Login failed: ${e.message}', e);
      _handleApiError('Login Failed', e);
    } catch (e) {
      AppLogger.error('Login error', e);
      Get.snackbar('Error', 'An unexpected error occurred');
    }
  }
}
```